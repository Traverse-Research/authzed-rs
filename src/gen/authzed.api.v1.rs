// This file is @generated by prost-build.
/// Relationship specifies how a resource relates to a subject. Relationships
/// form the data for the graph over which all permissions questions are
/// answered.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relationship {
    /// resource is the resource to which the subject is related, in some manner
    #[prost(message, optional, tag = "1")]
    pub resource: ::core::option::Option<ObjectReference>,
    /// relation is how the resource and subject are related.
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    /// subject is the subject to which the resource is related, in some manner.
    #[prost(message, optional, tag = "3")]
    pub subject: ::core::option::Option<SubjectReference>,
}
/// SubjectReference is used for referring to the subject portion of a
/// Relationship. The relation component is optional and is used for defining a
/// sub-relation on the subject, e.g. group:123#members
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubjectReference {
    #[prost(message, optional, tag = "1")]
    pub object: ::core::option::Option<ObjectReference>,
    #[prost(string, tag = "2")]
    pub optional_relation: ::prost::alloc::string::String,
}
/// ObjectReference is used to refer to a specific object in the system.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectReference {
    #[prost(string, tag = "1")]
    pub object_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub object_id: ::prost::alloc::string::String,
}
/// ZedToken is used to provide causality metadata between Write and Check
/// requests.
///
/// See the authzed.api.v1.Consistency message for more information.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZedToken {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// RelationshipUpdate is used for mutating a single relationship within the
/// service.
///
/// CREATE will create the relationship only if it doesn't exist, and error
/// otherwise.
///
/// TOUCH will upsert the relationship, and will not error if it
/// already exists.
///
/// DELETE will delete the relationship and error if it doesn't
/// exist.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationshipUpdate {
    #[prost(enumeration = "relationship_update::Operation", tag = "1")]
    pub operation: i32,
    #[prost(message, optional, tag = "2")]
    pub relationship: ::core::option::Option<Relationship>,
}
/// Nested message and enum types in `RelationshipUpdate`.
pub mod relationship_update {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operation {
        Unspecified = 0,
        Create = 1,
        Touch = 2,
        Delete = 3,
    }
    impl Operation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Operation::Unspecified => "OPERATION_UNSPECIFIED",
                Operation::Create => "OPERATION_CREATE",
                Operation::Touch => "OPERATION_TOUCH",
                Operation::Delete => "OPERATION_DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                "OPERATION_CREATE" => Some(Self::Create),
                "OPERATION_TOUCH" => Some(Self::Touch),
                "OPERATION_DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
/// PermissionRelationshipTree is used for representing a tree of a resource and
/// its permission relationships with other objects.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionRelationshipTree {
    #[prost(message, optional, tag = "3")]
    pub expanded_object: ::core::option::Option<ObjectReference>,
    #[prost(string, tag = "4")]
    pub expanded_relation: ::prost::alloc::string::String,
    #[prost(oneof = "permission_relationship_tree::TreeType", tags = "1, 2")]
    pub tree_type: ::core::option::Option<permission_relationship_tree::TreeType>,
}
/// Nested message and enum types in `PermissionRelationshipTree`.
pub mod permission_relationship_tree {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TreeType {
        #[prost(message, tag = "1")]
        Intermediate(super::AlgebraicSubjectSet),
        #[prost(message, tag = "2")]
        Leaf(super::DirectSubjectSet),
    }
}
/// AlgebraicSubjectSet is a subject set which is computed based on applying the
/// specified operation to the operands according to the algebra of sets.
///
/// UNION is a logical set containing the subject members from all operands.
///
/// INTERSECTION is a logical set containing only the subject members which are
/// present in all operands.
///
/// EXCLUSION is a logical set containing only the subject members which are
/// present in the first operand, and none of the other operands.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlgebraicSubjectSet {
    #[prost(enumeration = "algebraic_subject_set::Operation", tag = "1")]
    pub operation: i32,
    #[prost(message, repeated, tag = "2")]
    pub children: ::prost::alloc::vec::Vec<PermissionRelationshipTree>,
}
/// Nested message and enum types in `AlgebraicSubjectSet`.
pub mod algebraic_subject_set {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operation {
        Unspecified = 0,
        Union = 1,
        Intersection = 2,
        Exclusion = 3,
    }
    impl Operation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Operation::Unspecified => "OPERATION_UNSPECIFIED",
                Operation::Union => "OPERATION_UNION",
                Operation::Intersection => "OPERATION_INTERSECTION",
                Operation::Exclusion => "OPERATION_EXCLUSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                "OPERATION_UNION" => Some(Self::Union),
                "OPERATION_INTERSECTION" => Some(Self::Intersection),
                "OPERATION_EXCLUSION" => Some(Self::Exclusion),
                _ => None,
            }
        }
    }
}
/// DirectSubjectSet is a subject set which is simply a collection of subjects.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectSubjectSet {
    #[prost(message, repeated, tag = "1")]
    pub subjects: ::prost::alloc::vec::Vec<SubjectReference>,
}
/// Consistency will define how a request is handled by the backend.
/// By defining a consistency requirement, and a token at which those
/// requirements should be applied, where applicable.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Consistency {
    #[prost(oneof = "consistency::Requirement", tags = "1, 2, 3, 4")]
    pub requirement: ::core::option::Option<consistency::Requirement>,
}
/// Nested message and enum types in `Consistency`.
pub mod consistency {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Requirement {
        /// minimize_latency indicates that the latency for the call should be
        /// minimized by having the system select the fastest snapshot available.
        #[prost(bool, tag = "1")]
        MinimizeLatency(bool),
        /// at_least_as_fresh indicates that all data used in the API call must be
        /// *at least as fresh* as that found in the ZedToken; more recent data might
        /// be used if available or faster.
        #[prost(message, tag = "2")]
        AtLeastAsFresh(super::ZedToken),
        /// at_exact_snapshot indicates that all data used in the API call must be
        /// *at the given* snapshot in time; if the snapshot is no longer available,
        /// an error will be returned to the caller.
        #[prost(message, tag = "3")]
        AtExactSnapshot(super::ZedToken),
        /// fully_consistent indicates that all data used in the API call *must* be
        /// at the most recent snapshot found.
        ///
        /// NOTE: using this method can be *quite slow*, so unless there is a need to
        /// do so, it is recommended to use `at_least_as_fresh` with a stored
        /// ZedToken.
        #[prost(bool, tag = "4")]
        FullyConsistent(bool),
    }
}
/// RelationshipFilter is a collection of filters which when applied to a
/// relationship will return relationships that have exactly matching fields.
///
/// resource_type is required. All other fields are optional and if left
/// unspecified will not filter relationships.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationshipFilter {
    #[prost(string, tag = "1")]
    pub resource_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub optional_resource_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub optional_relation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub optional_subject_filter: ::core::option::Option<SubjectFilter>,
}
/// SubjectFilter specifies a filter on the subject of a relationship.
///
/// subject_type is required and all other fields are optional, and will not
/// impose any additional requirements if left unspecified.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubjectFilter {
    #[prost(string, tag = "1")]
    pub subject_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub optional_subject_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub optional_relation: ::core::option::Option<subject_filter::RelationFilter>,
}
/// Nested message and enum types in `SubjectFilter`.
pub mod subject_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RelationFilter {
        #[prost(string, tag = "1")]
        pub relation: ::prost::alloc::string::String,
    }
}
/// ReadRelationshipsRequest specifies one or more filters used to read matching
/// relationships within the system.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRelationshipsRequest {
    #[prost(message, optional, tag = "1")]
    pub consistency: ::core::option::Option<Consistency>,
    #[prost(message, optional, tag = "2")]
    pub relationship_filter: ::core::option::Option<RelationshipFilter>,
}
/// ReadRelationshipsResponse contains a Relationship found that matches the
/// specified relationship filter(s). A instance of this response message will
/// be streamed to the client for each relationship found.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRelationshipsResponse {
    #[prost(message, optional, tag = "1")]
    pub read_at: ::core::option::Option<ZedToken>,
    #[prost(message, optional, tag = "2")]
    pub relationship: ::core::option::Option<Relationship>,
}
/// Precondition specifies how and the existence or absence of certain
/// relationships as expressed through the accompanying filter should affect
/// whether or not the operation proceeds.
///
/// MUST_NOT_MATCH will fail the parent request if any relationships match the
/// relationships filter.
/// MUST_MATCH will fail the parent request if there are no
/// relationships that match the filter.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Precondition {
    #[prost(enumeration = "precondition::Operation", tag = "1")]
    pub operation: i32,
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<RelationshipFilter>,
}
/// Nested message and enum types in `Precondition`.
pub mod precondition {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operation {
        Unspecified = 0,
        MustNotMatch = 1,
        MustMatch = 2,
    }
    impl Operation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Operation::Unspecified => "OPERATION_UNSPECIFIED",
                Operation::MustNotMatch => "OPERATION_MUST_NOT_MATCH",
                Operation::MustMatch => "OPERATION_MUST_MATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                "OPERATION_MUST_NOT_MATCH" => Some(Self::MustNotMatch),
                "OPERATION_MUST_MATCH" => Some(Self::MustMatch),
                _ => None,
            }
        }
    }
}
/// WriteRelationshipsRequest contains a list of Relationship mutations that
/// should be applied to the service. If the optional_preconditions parameter
/// is included, all of the specified preconditions must also be satisfied before
/// the write will be committed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRelationshipsRequest {
    #[prost(message, repeated, tag = "1")]
    pub updates: ::prost::alloc::vec::Vec<RelationshipUpdate>,
    /// To be bounded by configuration
    #[prost(message, repeated, tag = "2")]
    pub optional_preconditions: ::prost::alloc::vec::Vec<Precondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRelationshipsResponse {
    #[prost(message, optional, tag = "1")]
    pub written_at: ::core::option::Option<ZedToken>,
}
/// DeleteRelationshipsRequest specifies which Relationships should be deleted,
/// requesting the delete of *ALL* relationships that match the specified
/// filters. If the optional_preconditions parameter is included, all of the
/// specified preconditions must also be satisfied before the delete will be
/// executed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRelationshipsRequest {
    #[prost(message, optional, tag = "1")]
    pub relationship_filter: ::core::option::Option<RelationshipFilter>,
    /// To be bounded by configuration
    #[prost(message, repeated, tag = "2")]
    pub optional_preconditions: ::prost::alloc::vec::Vec<Precondition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRelationshipsResponse {
    #[prost(message, optional, tag = "1")]
    pub deleted_at: ::core::option::Option<ZedToken>,
}
/// CheckPermissionRequest issues a check on whether a subject has a permission
/// or is a member of a relation, on a specific resource.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckPermissionRequest {
    #[prost(message, optional, tag = "1")]
    pub consistency: ::core::option::Option<Consistency>,
    /// resource is the resource on which to check the permission or relation.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<ObjectReference>,
    /// permission is the name of the permission (or relation) on which to execute
    /// the check.
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
    /// subject is the subject that will be checked for the permission or relation.
    #[prost(message, optional, tag = "4")]
    pub subject: ::core::option::Option<SubjectReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckPermissionResponse {
    #[prost(message, optional, tag = "1")]
    pub checked_at: ::core::option::Option<ZedToken>,
    /// Permissionship communicates whether or not the subject has the requested
    /// permission or has a relationship with the given resource, over the given
    /// relation.
    ///
    /// This value will be authzed.api.v1.PERMISSIONSHIP_HAS_PERMISSION if the
    /// requested subject is a member of the computed permission set or there
    /// exists a relationship with the requested relation from the given resource
    /// to the given subject.
    #[prost(enumeration = "check_permission_response::Permissionship", tag = "2")]
    pub permissionship: i32,
}
/// Nested message and enum types in `CheckPermissionResponse`.
pub mod check_permission_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Permissionship {
        Unspecified = 0,
        NoPermission = 1,
        HasPermission = 2,
    }
    impl Permissionship {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Permissionship::Unspecified => "PERMISSIONSHIP_UNSPECIFIED",
                Permissionship::NoPermission => "PERMISSIONSHIP_NO_PERMISSION",
                Permissionship::HasPermission => "PERMISSIONSHIP_HAS_PERMISSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERMISSIONSHIP_UNSPECIFIED" => Some(Self::Unspecified),
                "PERMISSIONSHIP_NO_PERMISSION" => Some(Self::NoPermission),
                "PERMISSIONSHIP_HAS_PERMISSION" => Some(Self::HasPermission),
                _ => None,
            }
        }
    }
}
/// ExpandPermissionTreeRequest returns a tree representing the expansion of all
/// relationships found accessible from a permission or relation on a particular
/// resource.
///
/// ExpandPermissionTreeRequest is typically used to determine the full set of
/// subjects with a permission, along with the relationships that grant said
/// access.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandPermissionTreeRequest {
    #[prost(message, optional, tag = "1")]
    pub consistency: ::core::option::Option<Consistency>,
    /// resource is the resource over which to run the expansion.
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<ObjectReference>,
    /// permission is the name of the permission or relation over which to run the
    /// expansion for the resource.
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandPermissionTreeResponse {
    #[prost(message, optional, tag = "1")]
    pub expanded_at: ::core::option::Option<ZedToken>,
    /// tree_root is a tree structure whose leaf nodes are subjects, and
    /// intermediate nodes represent the various operations (union, intersection,
    /// exclusion) to reach those subjects.
    #[prost(message, optional, tag = "2")]
    pub tree_root: ::core::option::Option<PermissionRelationshipTree>,
}
/// LookupResourcesRequest performs a lookup of all resources of a particular
/// kind on which the subject has the specified permission or the relation in
/// which the subject exists, streaming back the IDs of those resources.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupResourcesRequest {
    #[prost(message, optional, tag = "1")]
    pub consistency: ::core::option::Option<Consistency>,
    /// resource_object_type is the type of resource object for which the IDs will
    /// be returned.
    #[prost(string, tag = "2")]
    pub resource_object_type: ::prost::alloc::string::String,
    /// permission is the name of the permission or relation for which the subject
    /// must Check.
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
    /// subject is the subject with access to the resources.
    #[prost(message, optional, tag = "4")]
    pub subject: ::core::option::Option<SubjectReference>,
}
/// LookupResourcesResponse contains a single matching resource object ID for the
/// requested object type, permission, and subject.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupResourcesResponse {
    #[prost(message, optional, tag = "1")]
    pub looked_up_at: ::core::option::Option<ZedToken>,
    #[prost(string, tag = "2")]
    pub resource_object_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod permissions_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// PermissionsService is used to perform permissions and relationship
    /// operations.
    #[derive(Debug, Clone)]
    pub struct PermissionsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PermissionsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PermissionsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PermissionsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PermissionsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// ReadRelationships reads a set of the relationships matching one or more
        /// filters.
        pub async fn read_relationships(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ReadRelationshipsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.PermissionsService/ReadRelationships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "authzed.api.v1.PermissionsService",
                        "ReadRelationships",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// WriteRelationships writes and/or deletes a set of specified relationships,
        /// with an optional set of precondition relationships that must exist before
        /// the operation can commit.
        pub async fn write_relationships(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteRelationshipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.PermissionsService/WriteRelationships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "authzed.api.v1.PermissionsService",
                        "WriteRelationships",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeleteRelationships deletes relationships matching one or more filters, in
        /// bulk.
        pub async fn delete_relationships(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteRelationshipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.PermissionsService/DeleteRelationships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "authzed.api.v1.PermissionsService",
                        "DeleteRelationships",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CheckPermission checks whether a subject has a particular permission or is
        /// a member of a particular relation, on a given resource.
        pub async fn check_permission(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckPermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckPermissionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.PermissionsService/CheckPermission",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "authzed.api.v1.PermissionsService",
                        "CheckPermission",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ExpandPermissionTree expands the relationships reachable from a particular
        /// permission or relation of a given resource.
        pub async fn expand_permission_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::ExpandPermissionTreeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExpandPermissionTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.PermissionsService/ExpandPermissionTree",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "authzed.api.v1.PermissionsService",
                        "ExpandPermissionTree",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// LookupResources returns the IDs of all resources on which the specified
        /// subject has permission or on which the specified subject is a member of the
        /// relation.
        pub async fn lookup_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::LookupResourcesResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.PermissionsService/LookupResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "authzed.api.v1.PermissionsService",
                        "LookupResources",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod permissions_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PermissionsServiceServer.
    #[async_trait]
    pub trait PermissionsService: Send + Sync + 'static {
        /// Server streaming response type for the ReadRelationships method.
        type ReadRelationshipsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::ReadRelationshipsResponse,
                    tonic::Status,
                >,
            >
            + Send
            + 'static;
        /// ReadRelationships reads a set of the relationships matching one or more
        /// filters.
        async fn read_relationships(
            &self,
            request: tonic::Request<super::ReadRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ReadRelationshipsStream>,
            tonic::Status,
        >;
        /// WriteRelationships writes and/or deletes a set of specified relationships,
        /// with an optional set of precondition relationships that must exist before
        /// the operation can commit.
        async fn write_relationships(
            &self,
            request: tonic::Request<super::WriteRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteRelationshipsResponse>,
            tonic::Status,
        >;
        /// DeleteRelationships deletes relationships matching one or more filters, in
        /// bulk.
        async fn delete_relationships(
            &self,
            request: tonic::Request<super::DeleteRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteRelationshipsResponse>,
            tonic::Status,
        >;
        /// CheckPermission checks whether a subject has a particular permission or is
        /// a member of a particular relation, on a given resource.
        async fn check_permission(
            &self,
            request: tonic::Request<super::CheckPermissionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckPermissionResponse>,
            tonic::Status,
        >;
        /// ExpandPermissionTree expands the relationships reachable from a particular
        /// permission or relation of a given resource.
        async fn expand_permission_tree(
            &self,
            request: tonic::Request<super::ExpandPermissionTreeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExpandPermissionTreeResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the LookupResources method.
        type LookupResourcesStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::LookupResourcesResponse, tonic::Status>,
            >
            + Send
            + 'static;
        /// LookupResources returns the IDs of all resources on which the specified
        /// subject has permission or on which the specified subject is a member of the
        /// relation.
        async fn lookup_resources(
            &self,
            request: tonic::Request<super::LookupResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::LookupResourcesStream>,
            tonic::Status,
        >;
    }
    /// PermissionsService is used to perform permissions and relationship
    /// operations.
    #[derive(Debug)]
    pub struct PermissionsServiceServer<T: PermissionsService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: PermissionsService> PermissionsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for PermissionsServiceServer<T>
    where
        T: PermissionsService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/authzed.api.v1.PermissionsService/ReadRelationships" => {
                    #[allow(non_camel_case_types)]
                    struct ReadRelationshipsSvc<T: PermissionsService>(pub Arc<T>);
                    impl<
                        T: PermissionsService,
                    > tonic::server::ServerStreamingService<
                        super::ReadRelationshipsRequest,
                    > for ReadRelationshipsSvc<T> {
                        type Response = super::ReadRelationshipsResponse;
                        type ResponseStream = T::ReadRelationshipsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRelationshipsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PermissionsService>::read_relationships(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReadRelationshipsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/authzed.api.v1.PermissionsService/WriteRelationships" => {
                    #[allow(non_camel_case_types)]
                    struct WriteRelationshipsSvc<T: PermissionsService>(pub Arc<T>);
                    impl<
                        T: PermissionsService,
                    > tonic::server::UnaryService<super::WriteRelationshipsRequest>
                    for WriteRelationshipsSvc<T> {
                        type Response = super::WriteRelationshipsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteRelationshipsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PermissionsService>::write_relationships(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = WriteRelationshipsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/authzed.api.v1.PermissionsService/DeleteRelationships" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteRelationshipsSvc<T: PermissionsService>(pub Arc<T>);
                    impl<
                        T: PermissionsService,
                    > tonic::server::UnaryService<super::DeleteRelationshipsRequest>
                    for DeleteRelationshipsSvc<T> {
                        type Response = super::DeleteRelationshipsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteRelationshipsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PermissionsService>::delete_relationships(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = DeleteRelationshipsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/authzed.api.v1.PermissionsService/CheckPermission" => {
                    #[allow(non_camel_case_types)]
                    struct CheckPermissionSvc<T: PermissionsService>(pub Arc<T>);
                    impl<
                        T: PermissionsService,
                    > tonic::server::UnaryService<super::CheckPermissionRequest>
                    for CheckPermissionSvc<T> {
                        type Response = super::CheckPermissionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckPermissionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PermissionsService>::check_permission(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = CheckPermissionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/authzed.api.v1.PermissionsService/ExpandPermissionTree" => {
                    #[allow(non_camel_case_types)]
                    struct ExpandPermissionTreeSvc<T: PermissionsService>(pub Arc<T>);
                    impl<
                        T: PermissionsService,
                    > tonic::server::UnaryService<super::ExpandPermissionTreeRequest>
                    for ExpandPermissionTreeSvc<T> {
                        type Response = super::ExpandPermissionTreeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExpandPermissionTreeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PermissionsService>::expand_permission_tree(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ExpandPermissionTreeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/authzed.api.v1.PermissionsService/LookupResources" => {
                    #[allow(non_camel_case_types)]
                    struct LookupResourcesSvc<T: PermissionsService>(pub Arc<T>);
                    impl<
                        T: PermissionsService,
                    > tonic::server::ServerStreamingService<
                        super::LookupResourcesRequest,
                    > for LookupResourcesSvc<T> {
                        type Response = super::LookupResourcesResponse;
                        type ResponseStream = T::LookupResourcesStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LookupResourcesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PermissionsService>::lookup_resources(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = LookupResourcesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: PermissionsService> Clone for PermissionsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: PermissionsService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: PermissionsService> tonic::server::NamedService
    for PermissionsServiceServer<T> {
        const NAME: &'static str = "authzed.api.v1.PermissionsService";
    }
}
/// ReadSchemaRequest returns the schema from the database.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadSchemaRequest {}
/// ReadSchemaResponse is the resulting data after having read the Object
/// Definitions from a Schema.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadSchemaResponse {
    /// schema_text is the textual form of the current schema in the system
    #[prost(string, tag = "1")]
    pub schema_text: ::prost::alloc::string::String,
}
/// WriteSchemaRequest is the required data used to "upsert" the Schema of a
/// Permissions System.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteSchemaRequest {
    /// The Schema containing one or more Object Definitions that will be written
    /// to the Permissions System.
    ///
    /// 256KiB
    #[prost(string, tag = "1")]
    pub schema: ::prost::alloc::string::String,
}
/// WriteSchemaResponse is the resulting data after having written a Schema to
/// a Permissions System.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteSchemaResponse {}
/// Generated client implementations.
pub mod schema_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// SchemaService implements operations on a Permissions System's Schema.
    #[derive(Debug, Clone)]
    pub struct SchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SchemaServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Read returns the current Object Definitions for a Permissions System.
        ///
        /// Errors include:
        /// - INVALID_ARGUMENT: a provided value has failed to semantically validate
        /// - NOT_FOUND: no schema has been defined
        pub async fn read_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadSchemaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.SchemaService/ReadSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("authzed.api.v1.SchemaService", "ReadSchema"));
            self.inner.unary(req, path, codec).await
        }
        /// Write overwrites the current Object Definitions for a Permissions System.
        pub async fn write_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteSchemaResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.SchemaService/WriteSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("authzed.api.v1.SchemaService", "WriteSchema"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod schema_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SchemaServiceServer.
    #[async_trait]
    pub trait SchemaService: Send + Sync + 'static {
        /// Read returns the current Object Definitions for a Permissions System.
        ///
        /// Errors include:
        /// - INVALID_ARGUMENT: a provided value has failed to semantically validate
        /// - NOT_FOUND: no schema has been defined
        async fn read_schema(
            &self,
            request: tonic::Request<super::ReadSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadSchemaResponse>,
            tonic::Status,
        >;
        /// Write overwrites the current Object Definitions for a Permissions System.
        async fn write_schema(
            &self,
            request: tonic::Request<super::WriteSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WriteSchemaResponse>,
            tonic::Status,
        >;
    }
    /// SchemaService implements operations on a Permissions System's Schema.
    #[derive(Debug)]
    pub struct SchemaServiceServer<T: SchemaService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: SchemaService> SchemaServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SchemaServiceServer<T>
    where
        T: SchemaService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/authzed.api.v1.SchemaService/ReadSchema" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::ReadSchemaRequest>
                    for ReadSchemaSvc<T> {
                        type Response = super::ReadSchemaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::read_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReadSchemaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/authzed.api.v1.SchemaService/WriteSchema" => {
                    #[allow(non_camel_case_types)]
                    struct WriteSchemaSvc<T: SchemaService>(pub Arc<T>);
                    impl<
                        T: SchemaService,
                    > tonic::server::UnaryService<super::WriteSchemaRequest>
                    for WriteSchemaSvc<T> {
                        type Response = super::WriteSchemaResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteSchemaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SchemaService>::write_schema(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = WriteSchemaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: SchemaService> Clone for SchemaServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: SchemaService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: SchemaService> tonic::server::NamedService for SchemaServiceServer<T> {
        const NAME: &'static str = "authzed.api.v1.SchemaService";
    }
}
/// WatchRequest specifies the object definitions for which we want to start
/// watching mutations, and an optional start snapshot for when to start
/// watching.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchRequest {
    #[prost(string, repeated, tag = "1")]
    pub optional_object_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub optional_start_cursor: ::core::option::Option<ZedToken>,
}
/// WatchResponse contains all tuple modification events in ascending
/// timestamp order, from the requested start snapshot to a snapshot
/// encoded in the watch response. The client can use the snapshot to resume
/// watching where the previous watch response left off.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchResponse {
    #[prost(message, repeated, tag = "1")]
    pub updates: ::prost::alloc::vec::Vec<RelationshipUpdate>,
    #[prost(message, optional, tag = "2")]
    pub changes_through: ::core::option::Option<ZedToken>,
}
/// Generated client implementations.
pub mod watch_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct WatchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WatchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WatchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WatchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            WatchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn watch(
            &mut self,
            request: impl tonic::IntoRequest<super::WatchRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WatchResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/authzed.api.v1.WatchService/Watch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("authzed.api.v1.WatchService", "Watch"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod watch_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with WatchServiceServer.
    #[async_trait]
    pub trait WatchService: Send + Sync + 'static {
        /// Server streaming response type for the Watch method.
        type WatchStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::WatchResponse, tonic::Status>,
            >
            + Send
            + 'static;
        async fn watch(
            &self,
            request: tonic::Request<super::WatchRequest>,
        ) -> std::result::Result<tonic::Response<Self::WatchStream>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct WatchServiceServer<T: WatchService> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: WatchService> WatchServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for WatchServiceServer<T>
    where
        T: WatchService,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/authzed.api.v1.WatchService/Watch" => {
                    #[allow(non_camel_case_types)]
                    struct WatchSvc<T: WatchService>(pub Arc<T>);
                    impl<
                        T: WatchService,
                    > tonic::server::ServerStreamingService<super::WatchRequest>
                    for WatchSvc<T> {
                        type Response = super::WatchResponse;
                        type ResponseStream = T::WatchStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WatchRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WatchService>::watch(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = WatchSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: WatchService> Clone for WatchServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: WatchService> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: WatchService> tonic::server::NamedService for WatchServiceServer<T> {
        const NAME: &'static str = "authzed.api.v1.WatchService";
    }
}
